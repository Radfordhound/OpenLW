// TODO: Both the name of this file and its path were guessed!
// NOTE: Initial file was auto-generated by SymbolsDB.
#pragma once
#include <iterator>
#include <memory>
#include <cstddef>
#include <csl/ut/number.h>

namespace app
{
template<typename T, class Allocator = typename std::allocator<T>>
class TArray
{
OPENLW_PRIVATE
    T*              m_data;
    std::size_t     m_count;
    std::size_t     m_capacityAndFlags;

    // TODO: Does this function actually exist?
    static T* allocateMemory(std::size_t count)
    {
        Allocator alloc;
        return alloc.allocate(count);
    }

public:
    typedef T                                       value_type;
    typedef Allocator                               allocator_type;
    typedef std::size_t                             size_type;
    typedef std::ptrdiff_t                          difference_type;
    typedef const T*                                const_iterator;
    typedef value_type&                             reference;
    typedef const value_type&                       const_reference;
    typedef value_type*                             pointer;
    typedef const value_type*                       const_pointer;
    typedef pointer                                 iterator;
    typedef const_pointer                           const_iterator;
    typedef std::reverse_iterator<iterator>         reverse_iterator;
    typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;

    inline std::size_t size() const
    {
        return m_count;
    }

    // TODO: Does this function actually exist?
    inline std::size_t capacity() const
    {
        return (m_capacityAndFlags & ~CSL_HIGH_BITMASK(m_capacityAndFlags));
    }

    inline const_iterator begin() const
    {
        return m_data;
    }

    inline const_iterator end() const
    {
        return m_data + m_count;
    }

    inline iterator begin()
    {
        return m_data;
    }

    inline iterator end()
    {
        return m_data + m_count;
    }

    reference front()
    {
        return *(m_data);
    }

    reference back()
    {
        return *(m_data + m_count - 1);
    }

    inline bool empty() const
    {
        return m_data == 0;
    }

    void releaseMemory()
    {
        // TODO: It looks like they actually don't call per-object destructors?? Is this correct?

        if (CSL_HIGH_BIT(m_capacityAndFlags) == 0)
        {
            Allocator alloc;
            alloc.deallocate(m_data, m_count);
        }
    }

    void copy(iterator dst, const_iterator src, std::size_t count)
    {
        for (std::size_t i = 0; i < count; ++i)
        {
            dst[i] = src[i];
        }
    }

    // TODO: Is this function actually a thing?
    void reserve_unchecked(std::size_t newCapacity)
    {
        T* newData = allocateMemory(newCapacity);

        copy(newData, m_data, m_count);
        releaseMemory();

        m_data = newData;
        m_capacityAndFlags = newCapacity;
    }

    void reserve(std::size_t newCapacity)
    {
        if (capacity() < newCapacity)
        {
            reserve_unchecked(newCapacity);
        }
    }

    void resize(std::size_t count)
    {
        reserve(count);
        m_count = count;
    }

    void resize_unchecked(std::size_t count)
    {
        m_count = count;
    }

    iterator expand_unchecked(std::size_t amount)
    {
        const std::size_t oldCount = m_count;
        m_count += amount;
        return (m_data + oldCount);
    }

    void push_back_unchecked(const T& val)
    {
        new (m_data + m_count++) T(val);
    }

    void push_back(const T& val)
    {
        if (m_count == capacity())
        {
            reserve_unchecked((m_count != 0) ? m_count * 2 : 1);
        }

        push_back_unchecked(val);
    }

    void pop_back()
    {
        // TODO: It looks like they actually don't call per-object destructors?? Is this correct?
        --m_count;
    }

    void erase_unstable(iterator it)
    {
        --m_count;
        iterator lastElemIt = end();

        if (it != lastElemIt)
        {
            *it = *lastElemIt;
        }
    }

    iterator erase(iterator it)
    {
        --m_count;

        for (std::size_t i = (it - m_data); i < m_count; ++i)
        {
            m_data[i] = m_data[i + 1];
        }

        // TODO: It looks like they actually don't call per-object destructors?? Is this correct?
        return it;
    }

    void clear()
    {
        // TODO: It looks like they actually don't call per-object destructors?? Is this correct?
        m_count = 0;
    }

    inline const T& operator[](std::size_t index) const
    {
        return m_data[index];
    }

    inline T& operator[](std::size_t index)
    {
        return m_data[index];
    }

    TArray<T, Allocator>& operator=(const TArray<T, Allocator>& other)
    {
        if (capacity() < other.size())
        {
            releaseMemory();

            m_data = allocateMemory(other.size());
            m_capacityAndFlags = other.size();
        }

        m_count = other.size();
        copy(m_data, other.m_data, m_count);

        return *this;
    }

    TArray()
        : m_data(nullptr)
        , m_count(0)
        , m_capacityAndFlags(CSL_HIGH_BITMASK(m_capacityAndFlags))
    {
    }

    TArray(size_type count)
        : m_data(allocateMemory(count))
        , m_count(count)
        , m_capacityAndFlags(count)
    {
    }

    TArray(size_type count, const T& value)
        : m_data(allocateMemory(count))
        , m_count(count)
        , m_capacityAndFlags(count)
    {
        // TODO: Is the following actually just a call to std::uninitialized_fill ?
        for (size_type i = 0; i < count; ++i)
        {
            new (m_data + i) T(value);
        }
    }

    ~TArray()
    {
        releaseMemory();
    }
};
} // app
