// TODO: The name of this file is correct, but the path was guessed!
// NOTE: Initial file was auto-generated by SymbolsDB.
#pragma once
#include "ReferencedObject.h"
#include <cstdint>

namespace app
{
namespace fnd
{
class RefByHandleObject;

struct HandleTableEntry
{
    void* handle;
    RefByHandleObject* obj;
};

class HandleBase
{
OPENLW_PRIVATE
    void* m_handle;
    HandleTableEntry* m_entry;

public:
    LWAPI(0x0219EAA8, TODO)
    bool IsValid() const;

    LWAPI(0x0219EAE0, TODO)
    bool operator==(const HandleBase& other) const;

    LWAPI(0x0219EB44, TODO)
    bool operator==(const RefByHandleObject* obj) const;

    LWAPI(0x0219EBA4, TODO)
    bool operator!=(const HandleBase& other) const;

    LWAPI(0x0219EBCC, TODO)
    bool operator!=(const RefByHandleObject* obj) const;

    LWAPI(0x0219EBF4, TODO)
    HandleBase() :
        m_handle(nullptr),
        m_entry(nullptr) {}

    LWAPI(0x0219EC34, TODO)
    HandleBase(const HandleBase& other) :
        m_handle(other.m_handle),
        m_entry(other.m_entry) {}

    LWAPI(0x0219EC84, TODO)
    HandleBase(const RefByHandleObject* obj);

    LWAPI(0x0219ECEC, TODO)
    void* Get() const;

    LWAPI(0x0219ED28, TODO)
    HandleBase& operator=(const HandleBase& other);

    LWAPI(0x0219ED3C, TODO)
    HandleBase& operator=(const RefByHandleObject* obj);
};

template<typename T>
class Handle : public HandleBase
{
public:
    Handle(const Handle<T>& other) :
        HandleBase(other) {}

    Handle<T>& operator=(const Handle<T>& other)
    {
        HandleBase::operator=(other);
        return *this;
    }

    Handle() {}

    Handle(const RefByHandleObject* param_1) :
        HandleBase(param_1) {}

    T* Get() const
    {
        return static_cast<T*>(HandleBase::Get());
    }
};

class RefByHandleObject : public ReferencedObject
{
OPENLW_PRIVATE
    friend HandleBase;
    HandleBase m_handleObj;

public:
    LWAPI(0x0216D294, NONE)
    ~RefByHandleObject() {}
};
} // fnd
} // app
