// TODO: The name of this file is correct, but the path was guessed!
// NOTE: Initial file was auto-generated by SymbolsDB.
#pragma once
#include <cstdint>

namespace app
{
namespace fnd
{
class RefByHandleObject;

struct HandleTableEntry
{
    std::uintptr_t Handle;
    RefByHandleObject* Obj;
};

class HandleBase
{
OPENLW_PRIVATE
    void* m_handle;
    HandleTableEntry m_entry;

public:
    LWAPI(0x0219EAA8, TODO)
    bool IsValid() const;

    LWAPI(0x0219EAE0, TODO)
    bool operator==(const HandleBase& param_1) const;

    LWAPI(0x0219EB44, TODO)
    bool operator==(const RefByHandleObject* param_1) const;

    LWAPI(0x0219EBA4, TODO)
    bool operator!=(const HandleBase& param_1) const;

    LWAPI(0x0219EBCC, TODO)
    bool operator!=(const RefByHandleObject* param_1) const;

    LWAPI(0x0219EBF4, TODO)
    HandleBase();

    LWAPI(0x0219EC34, TODO)
    HandleBase(const HandleBase& param_1);

    LWAPI(0x0219EC84, TODO)
    HandleBase(const RefByHandleObject* param_1);

    LWAPI(0x0219ECEC, TODO)
    void* Get() const;

    LWAPI(0x0219ED28, TODO)
    HandleBase& operator=(const HandleBase& param_1);

    LWAPI(0x0219ED3C, TODO)
    HandleBase& operator=(const RefByHandleObject* param_1);
};

template<typename T>
class Handle : public HandleBase
{
public:
    Handle(const Handle<T>& other) :
        HandleBase(other) {}

    Handle<T>& operator=(const Handle<T>& other)
    {
        HandleBase::operator=(other);
        return *this;
    }

    Handle() {}

    Handle(const RefByHandleObject* param_1) :
        HandleBase(param_1) {}

    T* Get() const
    {
        return static_cast<T*>(HandleBase::Get());
    }
};
} // fnd
} // app
